#并发
学习操作系统的同学都知道，通过多道程序设计进行并发处理能够有效提高计算机系统软硬件资源的利用率。但多道程序设计中，由于资源共享导致程序运行的封闭环境被破坏，使得对共享资源的访问可能出现与运行过程相关的问题，从而产生诡异的计算结果错误，错误的原因非常难以查找，因此必须正确地处理共享资源的访问问题。

对该问题的一种通用解决途径是锁机制，在访问共享资源前加锁，访问完毕后解锁，从而保障程序在并发执行时对共享资源进行互斥访问。现有一个非常简单的并发执行原型系统，可以支持若干语句的并发执行。系统中的语句主要有以下几种类型：

 - `v = v1 or const1`：为全局变量v赋值，`const1`表示某个具体的数值（如1、2...），V1为另一个全局变量，若未出现，初始值默认为0，下同
 - `v += v1 or const1`：算术加运算，`v1`为另一个全局变量
 - `print v`：输出变量v的值
 - `lock`：加锁
 - `unlock`：解锁
 - `yield`：当前程序让出处理器，其剩余时间配额作废
 - `end`：程序结束
 
上述每条语句运行分别需要`t1`,`t2`,`t3`,`t4`,`t5`,`t6`,`t7`个时间单位。每个程序每次运行时最多分配到`Slice`个时间单位（配额），一旦执行某条语句时当前程序的配额用完，则执行完该语句后当前程序即进入就绪队列中队尾排队，等候下次运行机会。调度器会从就绪队列队首取出下一个程序并执行之。

开始时，系统中所有变量的初始值均为0，所有程序按编号顺序在就绪队列中排队等待执行。由于共享资源访问的问题，程序中可能存在`lock`语句。`lock`/`unlock`语句总是成对在同一程序中出现，且任意两对`lock`语句之间不会嵌套。`lock`语句的作用是请求获取变量的独占访问权（当然未`lock`直接访问的错误做法是无法阻止的），且总位于`unlock`语句之前。若某个程序成功执行完`lock`语句但尚未执行`unlock`语句便进入就绪状态，其他程序尝试运行执行`lock`语句时会被置入一个阻塞队列的尾部(对应的`lock`语句未执行，该程序的剩余时间配额作废)。此时调度器会调度下一个就绪程序运行。若引发`lock`的程序中对应的`unlock`语句执行完毕，则阻塞队列非空时其队首程序会进入就绪队列的队头排队，以便能够尽可能快地执行，否则不受影响。

现有若干上述语句构成的程序，程序编号依次为`1,2,...,N`(N为程序个数)。规定程序中的所有变量均用单个字母表示，初始值默认为`0`。程序中的所有变量均为全局变量，即任何程序都可以访问自己和别的程序中的变量。程序中常量为绝对值不大于`100`的整数。

请你编写一个并发执行解释器，运行上述程序。

## 输入数据
输入的第一行为9个整数，依次为`N`,`Slice`,`t1`,`t2`,`t3`,`t4`,`t5`,`t6`,`t7`，由空格分隔。`N`为并发执行的程序数，`Slice`为调度给定的时间片大小，`t1`等表示前述七类语句运行所需时间单位数。随后是`N`个程序的语句，每个程序以`end`语句结束，保证同一程序中`lock`/`unlock`语句按顺序成对出现且无嵌套，每个程序的语句不超过`1000`条。

## 输出数据
按解释器中各程序中语句的执行过程，输出print语句对应的程序编号及变量的输出值。

### 样例输入
```shell script
3 1 1 1 1 1 1 1 1
a = 4
print a
lock
b = 9
print b
unlock
print b
end
a = c
yield
print a
lock
b = 8
print b
unlock
print b
end
b = 5
a += 17
print a
yield
print b
lock
b += -21
print b
unlock
print b
end
```
###样例输出
```shell script
1: 0
2: 17
3: 17
1: 9
3: 9
1: 9
2: 8
2: 8
3: -13
3: -13
```
